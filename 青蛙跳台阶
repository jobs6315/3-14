Hello，大家好！我是李同学，今天我们来研究一个经典问题，青蛙跳台阶

题目：
一只青蛙可以一次跳 1 级台阶或一次跳 2 级台阶。

例如:跳上第一级台阶只有一种跳法:直接跳 1 级即可。

跳上两级台阶,有两种跳法: 每次跳 1 级,跳两次; 或者一次跳 2 级.

问要跳上第 n 级台阶有多少种跳法?

分析：
我们首先假设有n级台阶，定义函数F（n）

当n=1时，毫无疑问，只有1种选择，青蛙只能跳1级台阶，那就是1，F(1)=1.

当n=2时，青蛙便有了2种选择，1）一次性跳2级台阶 。2）一次跳1级台阶，跳2次.分别是2，[1,1]，F(2)=2

当n=3时，青蛙便有了3种选择，1）一次跳1级台阶跳3次。2）前一次跳2级台阶跳1次，后一次跳1级台阶跳1次。3）前一次跳1级台阶跳一次，后一次跳2级台阶1次,分别是[1,1,1],[1,2],[2,1]，F(3)=3

下面我开始简写

当n=4时，青蛙有5种选择，分别是[1,1,1,1],[1,1,2],[1,2,1],[2,1,1],[2,2]，F（n）=5

当n=5时，青蛙有8种选择，分别是[1,1,1,1,1],[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1],[2,2,1],[2,1,2],[1,2,2]，F（n）=8

...................

根据结果我们不难发现这是斐波那契数列，1，2，3，5，8........

那什么时斐波那契数列呢？
查阅百度百科我们便知道

斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。

如何用c语言代码实现呢？
其实处理的方法有两种，是否采用递归，当递归的数字n很小的时候，并不会影响电脑运行效率，可是当数字n超过一定数值时，电脑便要运算很久，首先我们递归来看看这个问题，并且对代码进行优化

采用递归

int frog(int n)
{
    if (n == 1)
    {
        return 1;
    }
    if (n == 2)
    {
        return 2;
    }
    return frog(n - 1) + frog(n - 2);
}
int main()
{
    int n = 0;
    scanf_s("%d", &n);
    int ways = frog(n);
    printf("%d\n", ways);
    return 0;
    return 0;
}

代码其实并不复杂，不过出现了一个很致命的问题

当你输入10的时候，电脑会很快反应出来89



当你输入50的时候，电脑至少要过10分钟左右才会有反应，那么问题来了，为什么会出现这样的问题呢？ 

其实原理并不复杂，

当n=50的时候，那就意味着电脑需要知道F(49),F(48),F(47).....F(1)，这个运算量非常巨大

当电脑需要知道F（49）的时候，它有需要去求F(48），F(47).....F(1),这个运算量也非常大，

不难看出在这样的运算背后都伴随着大量重复，那如何优化算法呢？
我才用的方法很简单，不用递归，用循环

代码如下：

先列多项式：
   f(n) =  f(n-1) + f(n-2) + f(n-3) + ... + f(n-m)
   f(n-1) =   f(n-2) + f(n-3) + ... + f(n-m) + f(n-m-1)
   化简得：f(n) = 2f(n-1) - f(n-m-1)
   
     public static int Jump4(int n,int m ) {
         //当大于m的时候是上面的公式
         if(n > m){
             return 2*Jump4(n-1, m)-Jump4(n-1-m, m);
         }
         //当小于等于m的时候就是和n级的相同了
         if (n <= 1) {
             return 1;
         } else {
             return 2 * Jump4(n - 1,n);
         }
     }
}
这样就完美的解决上面的问题。

谢谢大家看到最后，我每天都会更新一篇这样的小问题，今天是第一篇

喜欢的小伙伴，记得留下你手里的赞哦

我是李同学，我们明天见
————————————————
版权声明：本文为CSDN博主「程序员李同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xuetudexintai/article/details/123483752
